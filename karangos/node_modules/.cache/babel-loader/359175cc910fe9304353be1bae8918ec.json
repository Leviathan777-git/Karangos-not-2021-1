{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOpposite = getOpposite;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getSibling = getSibling;\nexports.getPrevSibling = getPrevSibling;\nexports.getNextSibling = getNextSibling;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.get = get;\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst NORMAL_COMPLETION = 0;\nconst BREAK_COMPLETION = 1;\n\nfunction NormalCompletion(path) {\n  return {\n    type: NORMAL_COMPLETION,\n    path\n  };\n}\n\nfunction BreakCompletion(path) {\n  return {\n    type: BREAK_COMPLETION,\n    path\n  };\n}\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n\n  return null;\n}\n\nfunction addCompletionRecords(path, records, context) {\n  if (path) return records.concat(_getCompletionRecords(path, context));\n  return records;\n}\n\nfunction completionRecordForSwitch(cases, records, context) {\n  let lastNormalCompletions = [];\n\n  for (let i = 0; i < cases.length; i++) {\n    const casePath = cases[i];\n\n    const caseCompletions = _getCompletionRecords(casePath, context);\n\n    const normalCompletions = [];\n    const breakCompletions = [];\n\n    for (const c of caseCompletions) {\n      if (c.type === NORMAL_COMPLETION) {\n        normalCompletions.push(c);\n      }\n\n      if (c.type === BREAK_COMPLETION) {\n        breakCompletions.push(c);\n      }\n    }\n\n    if (normalCompletions.length) {\n      lastNormalCompletions = normalCompletions;\n    }\n\n    records = records.concat(breakCompletions);\n  }\n\n  records = records.concat(lastNormalCompletions);\n  return records;\n}\n\nfunction normalCompletionToBreak(completions) {\n  completions.forEach(c => {\n    c.type = BREAK_COMPLETION;\n  });\n}\n\nfunction replaceBreakStatementInBreakCompletion(completions, reachable) {\n  completions.forEach(c => {\n    if (c.path.isBreakStatement({\n      label: null\n    })) {\n      if (reachable) {\n        c.path.replaceWith(t.unaryExpression(\"void\", t.numericLiteral(0)));\n      } else {\n        c.path.remove();\n      }\n    }\n  });\n}\n\nfunction getStatementListCompletion(paths, context) {\n  let completions = [];\n\n  if (context.canHaveBreak) {\n    let lastNormalCompletions = [];\n\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i];\n      const newContext = Object.assign({}, context, {\n        inCaseClause: false\n      });\n\n      if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {\n        newContext.shouldPopulateBreak = true;\n      } else {\n        newContext.shouldPopulateBreak = false;\n      }\n\n      const statementCompletions = _getCompletionRecords(path, newContext);\n\n      if (statementCompletions.length > 0 && statementCompletions.every(c => c.type === BREAK_COMPLETION)) {\n        if (lastNormalCompletions.length > 0 && statementCompletions.every(c => c.path.isBreakStatement({\n          label: null\n        }))) {\n          normalCompletionToBreak(lastNormalCompletions);\n          completions = completions.concat(lastNormalCompletions);\n\n          if (lastNormalCompletions.some(c => c.path.isDeclaration())) {\n            completions = completions.concat(statementCompletions);\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n\n          replaceBreakStatementInBreakCompletion(statementCompletions, false);\n        } else {\n          completions = completions.concat(statementCompletions);\n\n          if (!context.shouldPopulateBreak) {\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n        }\n\n        break;\n      }\n\n      if (i === paths.length - 1) {\n        completions = completions.concat(statementCompletions);\n      } else {\n        completions = completions.concat(statementCompletions.filter(c => c.type === BREAK_COMPLETION));\n        lastNormalCompletions = statementCompletions.filter(c => c.type === NORMAL_COMPLETION);\n      }\n    }\n  } else if (paths.length) {\n    completions = completions.concat(_getCompletionRecords(paths[paths.length - 1], context));\n  }\n\n  return completions;\n}\n\nfunction _getCompletionRecords(path, context) {\n  let records = [];\n\n  if (path.isIfStatement()) {\n    records = addCompletionRecords(path.get(\"consequent\"), records, context);\n    records = addCompletionRecords(path.get(\"alternate\"), records, context);\n  } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {\n    records = addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isProgram() || path.isBlockStatement()) {\n    records = records.concat(getStatementListCompletion(path.get(\"body\"), context));\n  } else if (path.isFunction()) {\n    return _getCompletionRecords(path.get(\"body\"), context);\n  } else if (path.isTryStatement()) {\n    records = addCompletionRecords(path.get(\"block\"), records, context);\n    records = addCompletionRecords(path.get(\"handler\"), records, context);\n  } else if (path.isCatchClause()) {\n    records = addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isSwitchStatement()) {\n    records = completionRecordForSwitch(path.get(\"cases\"), records, context);\n  } else if (path.isSwitchCase()) {\n    records = records.concat(getStatementListCompletion(path.get(\"consequent\"), {\n      canHaveBreak: true,\n      shouldPopulateBreak: false,\n      inCaseClause: true\n    }));\n  } else if (path.isBreakStatement()) {\n    records.push(BreakCompletion(path));\n  } else {\n    records.push(NormalCompletion(path));\n  }\n\n  return records;\n}\n\nfunction getCompletionRecords() {\n  const records = _getCompletionRecords(this, {\n    canHaveBreak: false,\n    shouldPopulateBreak: false,\n    inCaseClause: false\n  });\n\n  return records.map(r => r.path);\n}\n\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  }).setContext(this.context);\n}\n\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\n\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\n\nfunction getAllNextSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n\n  return siblings;\n}\n\nfunction getAllPrevSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n\n  return siblings;\n}\n\nfunction get(key, context = true) {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n\n  if (parts.length === 1) {\n    return this._getKey(key, context);\n  } else {\n    return this._getPattern(parts, context);\n  }\n}\n\nfunction _getKey(key, context) {\n  const node = this.node;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    return container.map((_, i) => {\n      return _index.default.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\nfunction _getPattern(parts, context) {\n  let path = this;\n\n  for (const part of parts) {\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction getBindingIdentifiers(duplicates) {\n  return t.getBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getOuterBindingIdentifiers(duplicates) {\n  return t.getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getBindingIdentifierPaths(duplicates = false, outerOnly = false) {\n  const path = this;\n  let search = [].concat(path);\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    const keys = t.getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n\n      if (declaration.isDeclaration()) {\n        search.push(declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n\n        if (Array.isArray(child) || child.node) {\n          search = search.concat(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nfunction getOuterBindingIdentifierPaths(duplicates) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}","map":{"version":3,"sources":["/workspace/Karangos-not-2021-1/karangos/node_modules/@babel/traverse/lib/path/family.js"],"names":["Object","defineProperty","exports","value","getOpposite","getCompletionRecords","getSibling","getPrevSibling","getNextSibling","getAllNextSiblings","getAllPrevSiblings","get","_getKey","_getPattern","getBindingIdentifiers","getOuterBindingIdentifiers","getBindingIdentifierPaths","getOuterBindingIdentifierPaths","_index","_interopRequireDefault","require","t","_interopRequireWildcard","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","default","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","NORMAL_COMPLETION","BREAK_COMPLETION","NormalCompletion","path","type","BreakCompletion","addCompletionRecords","records","context","concat","_getCompletionRecords","completionRecordForSwitch","cases","lastNormalCompletions","i","length","casePath","caseCompletions","normalCompletions","breakCompletions","c","push","normalCompletionToBreak","completions","forEach","replaceBreakStatementInBreakCompletion","reachable","isBreakStatement","label","replaceWith","unaryExpression","numericLiteral","remove","getStatementListCompletion","paths","canHaveBreak","newContext","assign","inCaseClause","isBlockStatement","shouldPopulateBreak","statementCompletions","every","some","isDeclaration","filter","isIfStatement","isDoExpression","isFor","isWhile","isLabeledStatement","isProgram","isFunction","isTryStatement","isCatchClause","isSwitchStatement","isSwitchCase","map","r","parentPath","parent","container","listKey","setContext","_key","sibling","siblings","node","parts","split","Array","isArray","_","part","duplicates","outerOnly","search","ids","create","id","shift","keys","isIdentifier","_ids","name","isExportDeclaration","declaration","isFunctionDeclaration","isFunctionExpression","child"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOpposite = getOpposite;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getSibling = getSibling;\nexports.getPrevSibling = getPrevSibling;\nexports.getNextSibling = getNextSibling;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.get = get;\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\n\nvar _index = _interopRequireDefault(require(\"./index\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst NORMAL_COMPLETION = 0;\nconst BREAK_COMPLETION = 1;\n\nfunction NormalCompletion(path) {\n  return {\n    type: NORMAL_COMPLETION,\n    path\n  };\n}\n\nfunction BreakCompletion(path) {\n  return {\n    type: BREAK_COMPLETION,\n    path\n  };\n}\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n\n  return null;\n}\n\nfunction addCompletionRecords(path, records, context) {\n  if (path) return records.concat(_getCompletionRecords(path, context));\n  return records;\n}\n\nfunction completionRecordForSwitch(cases, records, context) {\n  let lastNormalCompletions = [];\n\n  for (let i = 0; i < cases.length; i++) {\n    const casePath = cases[i];\n\n    const caseCompletions = _getCompletionRecords(casePath, context);\n\n    const normalCompletions = [];\n    const breakCompletions = [];\n\n    for (const c of caseCompletions) {\n      if (c.type === NORMAL_COMPLETION) {\n        normalCompletions.push(c);\n      }\n\n      if (c.type === BREAK_COMPLETION) {\n        breakCompletions.push(c);\n      }\n    }\n\n    if (normalCompletions.length) {\n      lastNormalCompletions = normalCompletions;\n    }\n\n    records = records.concat(breakCompletions);\n  }\n\n  records = records.concat(lastNormalCompletions);\n  return records;\n}\n\nfunction normalCompletionToBreak(completions) {\n  completions.forEach(c => {\n    c.type = BREAK_COMPLETION;\n  });\n}\n\nfunction replaceBreakStatementInBreakCompletion(completions, reachable) {\n  completions.forEach(c => {\n    if (c.path.isBreakStatement({\n      label: null\n    })) {\n      if (reachable) {\n        c.path.replaceWith(t.unaryExpression(\"void\", t.numericLiteral(0)));\n      } else {\n        c.path.remove();\n      }\n    }\n  });\n}\n\nfunction getStatementListCompletion(paths, context) {\n  let completions = [];\n\n  if (context.canHaveBreak) {\n    let lastNormalCompletions = [];\n\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i];\n      const newContext = Object.assign({}, context, {\n        inCaseClause: false\n      });\n\n      if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {\n          newContext.shouldPopulateBreak = true;\n        } else {\n        newContext.shouldPopulateBreak = false;\n      }\n\n      const statementCompletions = _getCompletionRecords(path, newContext);\n\n      if (statementCompletions.length > 0 && statementCompletions.every(c => c.type === BREAK_COMPLETION)) {\n        if (lastNormalCompletions.length > 0 && statementCompletions.every(c => c.path.isBreakStatement({\n          label: null\n        }))) {\n          normalCompletionToBreak(lastNormalCompletions);\n          completions = completions.concat(lastNormalCompletions);\n\n          if (lastNormalCompletions.some(c => c.path.isDeclaration())) {\n            completions = completions.concat(statementCompletions);\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n\n          replaceBreakStatementInBreakCompletion(statementCompletions, false);\n        } else {\n          completions = completions.concat(statementCompletions);\n\n          if (!context.shouldPopulateBreak) {\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n        }\n\n        break;\n      }\n\n      if (i === paths.length - 1) {\n        completions = completions.concat(statementCompletions);\n      } else {\n        completions = completions.concat(statementCompletions.filter(c => c.type === BREAK_COMPLETION));\n        lastNormalCompletions = statementCompletions.filter(c => c.type === NORMAL_COMPLETION);\n      }\n    }\n  } else if (paths.length) {\n    completions = completions.concat(_getCompletionRecords(paths[paths.length - 1], context));\n  }\n\n  return completions;\n}\n\nfunction _getCompletionRecords(path, context) {\n  let records = [];\n\n  if (path.isIfStatement()) {\n    records = addCompletionRecords(path.get(\"consequent\"), records, context);\n    records = addCompletionRecords(path.get(\"alternate\"), records, context);\n  } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {\n    records = addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isProgram() || path.isBlockStatement()) {\n    records = records.concat(getStatementListCompletion(path.get(\"body\"), context));\n  } else if (path.isFunction()) {\n    return _getCompletionRecords(path.get(\"body\"), context);\n  } else if (path.isTryStatement()) {\n    records = addCompletionRecords(path.get(\"block\"), records, context);\n    records = addCompletionRecords(path.get(\"handler\"), records, context);\n  } else if (path.isCatchClause()) {\n    records = addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isSwitchStatement()) {\n    records = completionRecordForSwitch(path.get(\"cases\"), records, context);\n  } else if (path.isSwitchCase()) {\n    records = records.concat(getStatementListCompletion(path.get(\"consequent\"), {\n      canHaveBreak: true,\n      shouldPopulateBreak: false,\n      inCaseClause: true\n    }));\n  } else if (path.isBreakStatement()) {\n    records.push(BreakCompletion(path));\n  } else {\n    records.push(NormalCompletion(path));\n  }\n\n  return records;\n}\n\nfunction getCompletionRecords() {\n  const records = _getCompletionRecords(this, {\n    canHaveBreak: false,\n    shouldPopulateBreak: false,\n    inCaseClause: false\n  });\n\n  return records.map(r => r.path);\n}\n\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  }).setContext(this.context);\n}\n\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\n\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\n\nfunction getAllNextSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n\n  return siblings;\n}\n\nfunction getAllPrevSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n\n  return siblings;\n}\n\nfunction get(key, context = true) {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n\n  if (parts.length === 1) {\n    return this._getKey(key, context);\n  } else {\n    return this._getPattern(parts, context);\n  }\n}\n\nfunction _getKey(key, context) {\n  const node = this.node;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    return container.map((_, i) => {\n      return _index.default.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\nfunction _getPattern(parts, context) {\n  let path = this;\n\n  for (const part of parts) {\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction getBindingIdentifiers(duplicates) {\n  return t.getBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getOuterBindingIdentifiers(duplicates) {\n  return t.getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getBindingIdentifierPaths(duplicates = false, outerOnly = false) {\n  const path = this;\n  let search = [].concat(path);\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    const keys = t.getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n\n      if (declaration.isDeclaration()) {\n        search.push(declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n\n        if (Array.isArray(child) || child.node) {\n          search = search.concat(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nfunction getOuterBindingIdentifierPaths(duplicates) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}"]},"metadata":{},"sourceType":"script"}